<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot整合Thymeleaf(三)</title>
      <link href="/SpringBoot2.X%E6%95%B4%E5%90%88Thymeleaf.html"/>
      <url>/SpringBoot2.X%E6%95%B4%E5%90%88Thymeleaf.html</url>
      
        <content type="html"><![CDATA[<p>​    Thymeleaf是适用于Web和独立环境的现代服务器端Java模板引擎，SpringBoot官方推荐使用的一个模板引擎</p><p>如果你对模板和模板引擎没什么概念的话，可以简单理解为Thymeleaf是一个高级简洁的JSP</p><p>如果学过MVC设计模式，那么Thymeleaf就是视图层（view）的主要核心内容</p><h3 id="模板引擎是什么"><a href="#模板引擎是什么" class="headerlink" title="模板引擎是什么"></a>模板引擎是什么</h3><p>模板引擎是为了使用户界面与业务数据（内容）分离而产生的，它可以将特定格式的模板和数据通过模板引擎渲染就会生成一个标准的HTML文档页面</p><p>它最早出现是C#语言用来渲染成.asp，所以它不是什么新鲜事了，Thymeleaf则是Java的一个模板引擎，与Thymeleaf类似的模板引擎还有Velocity和FreeMarker</p><h3 id="模板引擎工作原理"><a href="#模板引擎工作原理" class="headerlink" title="模板引擎工作原理"></a>模板引擎工作原理</h3><p><img src="https://imgkr.cn-bj.ufileos.com/2af67ab9-f9f2-4dfc-8eac-4cc98ee3566e.jpg" alt><br>按照我自己理解模板引擎只是将模板(Template)和数据(Java Object)渲染成网页(Html)的工具</p><p>JSP知道吧，它里面参杂Java内置对象代码来进行数据显示，而Thymeleaf按照我的理解就像去除了Java代码的简化版JSP</p><h3 id="为什么要整合Thymeleaf"><a href="#为什么要整合Thymeleaf" class="headerlink" title="为什么要整合Thymeleaf"></a>为什么要整合Thymeleaf</h3><p>在SpringBoot2.X系列第一篇文章中整合的案例，各位应该有印象我没有去配置过Tomcat</p><p>因为SpringBoot将项目打包成<strong>Jar包方式在内部集成的Tomcat运行</strong>，传统JSP是要打成<strong>war包</strong>才能运行，所以这里不适用JSP必须整合Thymeleaf</p><p>使用Thymeleaf有助于前后端协同开发，因为它在无网络环境下也可以运行，前端程序员便于在静态页面查看页面效果，后端开发者也便于在服务器查看实时的数据交互</p><p>Thymeleaf严格遵循的mvc设计模式，不用像JSP页面大量嵌套Java代码，开发更简洁</p><h3 id="SpringBoot整合Thymeleaf"><a href="#SpringBoot整合Thymeleaf" class="headerlink" title="SpringBoot整合Thymeleaf"></a>SpringBoot整合Thymeleaf</h3><p>整合Thymeleaf需要Web模块和Thymeleaf模块相应的依赖Jar包</p><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--thymeleaf模块依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Web模块依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Themeleaf/SpringBoot-Thymeleaf-Module.png" alt><br>在SpringBoot Initializer中分别勾选Web和Thymeleaf</p><h3 id="整合Thymeleaf的项目结构"><a href="#整合Thymeleaf的项目结构" class="headerlink" title="整合Thymeleaf的项目结构"></a>整合Thymeleaf的项目结构</h3><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Themeleaf/20191226221317.png" alt="SpringBoot整合Thymeleaf的目录结构"><br>在SpringbootApplication所在的包下所有Bean类会被SpringBoot自动扫描组装，static目录是SpringBootyong用来加载CSS,JS,IMG等静态资源，templates是用来放置html模板文件</p><h3 id="ThymeleafController"><a href="#ThymeleafController" class="headerlink" title="ThymeleafController"></a>ThymeleafController</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luojay.springbootthymeleaf.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThymeleafController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getThymeleaf"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Welcome</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"luojay"</span>;</span><br><span class="line">        <span class="comment">//此处返回值，对应templates的文件名，SpringBoot根据它找到对应Html</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Controller注解是告知SpringBoot此类是控制层需要自动注入，@RequestMapping是映射访问路径注解，在localhost:8080之后的路径就是根据此处写的</p><h3 id="luojay-html"><a href="#luojay-html" class="headerlink" title="luojay.html"></a>luojay.html</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>luojay's Thymeleaf<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    hello,luojay!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="页面展示效果"><a href="#页面展示效果" class="headerlink" title="页面展示效果"></a>页面展示效果</h3><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Themeleaf/SpringBoot-Thymeleaf-runResult.png" alt></p><h3 id="进阶的学习案例"><a href="#进阶的学习案例" class="headerlink" title="进阶的学习案例"></a>进阶的学习案例</h3><p>上面的入门例子可以说是简单到不行，有了这个基础，可以利用网上一些静态资源整合Thymeleaf搭建好看的页面,比如登录界面<br><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Themeleaf/SpringBoot-Thymeleaf-login.gif" alt></p><h3 id="文章配套代码"><a href="#文章配套代码" class="headerlink" title="文章配套代码"></a>文章配套代码</h3><p>文章的配套源码已收录在我的GitHub仓库SpringBoot-Study中，点击阅读原文可以直达我的Github中的SpringBoot-Study仓库，如果案例的代码对你有帮助，欢迎star和fork！<br>Github:<a href="https://github.com/bobi8344/SpringBoot-Study/tree/master/springboot-thymeleaf" title="springboot-thymeleaf" rel="external nofollow noopener noreferrer" target="_blank">springboot-thymeleaf</a></p><p>登录页面源代码：<a href="https://www.17sucai.com/pins/34125.html" title="**基于Layui简约登录界面**" rel="external nofollow noopener noreferrer" target="_blank"><strong>基于Layui简约登录界面</strong></a></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot2.X系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot2.X快速入门案例</title>
      <link href="/SpringBoot2.X%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B.html"/>
      <url>/SpringBoot2.X%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Start/SpringBoot-start-index.jpg" alt></p><p>SpringBoot是一个配置很少就能轻松搭建Web应用框架，相信学过SSH或者SSM框架的开发者都知道在该框架环境下需要配置一堆XML配置文件才能实现搭建Web应用，学习完SpringBoot后，搭建Web应用会让你有丝滑般的畅快。</p><h2 id="SpringBoot2-2-2版本快速入门环境要求"><a href="#SpringBoot2-2-2版本快速入门环境要求" class="headerlink" title="SpringBoot2.2.2版本快速入门环境要求"></a>SpringBoot2.2.2版本快速入门环境要求</h2><p>目前<a href="https://spring.io/projects/spring-boot/" rel="external nofollow noopener noreferrer" target="_blank">Spring官网</a>官网正式发行的版本是2.2.2版本，在其<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/html/getting-started.html#getting-started" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>列出以下环境要求，本文也是基于2.2.2版本快速搭建入门的案例，所谓工欲善其事必先利其器，生产环境得搞起来。</p><table><thead><tr><th>工具</th><th>版本</th></tr></thead><tbody><tr><td>Maven</td><td>3.3+</td></tr><tr><td>Java</td><td>8    (即JDK1.8及以后版本)</td></tr><tr><td>Tomcat</td><td>9.0</td></tr></tbody></table><h2 id="通过IDEA的Spring-initializer快速搭建SpringBoot"><a href="#通过IDEA的Spring-initializer快速搭建SpringBoot" class="headerlink" title="通过IDEA的Spring initializer快速搭建SpringBoot"></a>通过IDEA的Spring initializer快速搭建SpringBoot</h2><p>SpringBoot快速搭建的工具有STS(Eclipse编程环境下常用)，Spring initializer（IDEA常用）,而官方文档推荐使用Maven构建工具基于Pom.xml文件引入依赖构建，以上的工具和搭建方式这里就见仁见智。</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Start/SpringBoot-start-1.png" alt></p><p>点击Next–&gt;输入包名和项目名–&gt;Next</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Start/SpringBoot-start-2.png" alt></p><p>勾选Web模块–&gt;Next</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Start/SpringBoot-start-3.png" alt></p><h2 id="Spring-initializer创建的SpringBoot文件目录结构"><a href="#Spring-initializer创建的SpringBoot文件目录结构" class="headerlink" title="Spring initializer创建的SpringBoot文件目录结构"></a>Spring initializer创建的SpringBoot文件目录结构</h2><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Start/SpringBoot-start-4.png" alt></p><p>这里只需要关注pom.xml和src文件夹下目录结构，只需要知道带有mvn的都是与Maven相关的，用于记录Maven版本信息和方便分布式部署，这里入门案例是单体部署，不需要用到，有强迫症可以删除带有mvn的文件和目录</p><table><thead><tr><th>对应的作用</th><th>文件夹</th></tr></thead><tbody><tr><td>存放maven-wrapper.properties和其jar包（可以忽略）</td><td>.mvn</td></tr><tr><td>标准的Maven目录结构(其目录下有main和test文件夹)</td><td>src</td></tr><tr><td>main文件夹存放Java源文件，test存放用于测试文件</td><td>src下的main</td></tr><tr><td>SpringBoot自动配置默认扫描的目录文件夹</td><td>src下的main的java下的com.xxx</td></tr><tr><td>是SpringBoot程序主入口</td><td>src下的main的java下的com.xxx的xxxApplication.java</td></tr><tr><td>用于存放静态资源文件如js,css.images</td><td>src下的main的resources下的static</td></tr><tr><td>用于存放模板引擎的文件如themeleaf，freemarker</td><td>src的main的resources下的templates</td></tr></tbody></table><p>这里补充说明，Controller是需要手动创建在<strong>xxxApplication</strong>所在的文件夹下，每个人起的包名和项目名不同所以会有所区别，<strong>因为该xxxApplication是程序主入口</strong>，其所在文件夹是SpringBoot自动配置默认扫描的目录文件夹相当于之前的SSM框架中component-scan的作用，自动配置Controller。</p><h2 id="编写控制层代码XXXController"><a href="#编写控制层代码XXXController" class="headerlink" title="编写控制层代码XXXController"></a>编写控制层代码XXXController</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.luojay.springbootstart.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span><span class="comment">//标注是控制层的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span><span class="comment">//以JSON格式输出到页面的注解</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)<span class="comment">//映射路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello SpringBoot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动XXXApplication访问映射路径"><a href="#启动XXXApplication访问映射路径" class="headerlink" title="启动XXXApplication访问映射路径"></a>启动XXXApplication访问映射路径</h2><p>点击绿色三角形启动web程序</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Start/SpringBoot-start-5.png" alt></p><p>在浏览器输入http:localhost:8080/hello 显示字符串即为完成入门案例</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Start/SpringBoot-start-6.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot2.X系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot入门案例修改默认配置(二)</title>
      <link href="/Spring%20Boot%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE(%E4%BA%8C).html"/>
      <url>/Spring%20Boot%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE(%E4%BA%8C).html</url>
      
        <content type="html"><![CDATA[<p>​        Spring Boot官方声称搭建Web应用开箱即用，其根本原因就是底层封装好大部分的约束和配置，而作为合格的开发者，肯定要对这些配置有点好奇心，修改定制成自己的Web应用才能用得舒服。最近在学习SpringBoot时搜索网上的一些教程看到修改Banner的教程，也尝试了一把，记录这个好玩的东西。</p><blockquote><h2 id="修改Spring-Banner"><a href="#修改Spring-Banner" class="headerlink" title="修改Spring Banner"></a>修改Spring Banner</h2></blockquote><p>​        首先来玩一个好玩的东西，就是修改Spring Boot默认的Banner，默认启动应用会输出Spring Banner如果我们自己做些小Demo，加上个性化Banner，可能会我们的程序更加逼格一点呢，早在Spring Boot 1.x 版本中就已经有了更换启动Banner的方法，并且使用起来非常简单。</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Banner/SpringBoot-Banner-banner.png" alt></p><blockquote><h3 id="triangular-flag-on-post-个性化修改Banner案例一：ASCII文字版本Bannner"><a href="#triangular-flag-on-post-个性化修改Banner案例一：ASCII文字版本Bannner" class="headerlink" title=":triangular_flag_on_post:个性化修改Banner案例一：ASCII文字版本Bannner"></a>:triangular_flag_on_post:个性化修改Banner案例一：ASCII文字版本Bannner</h3></blockquote><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Banner/SpringBoot-Banner-SteveJobs.png" alt></p><blockquote><h3 id="triangular-flag-on-post-个性化修改Banner案例二：Image转ASCII文字版本Bannner"><a href="#triangular-flag-on-post-个性化修改Banner案例二：Image转ASCII文字版本Bannner" class="headerlink" title=":triangular_flag_on_post:个性化修改Banner案例二：Image转ASCII文字版本Bannner"></a>:triangular_flag_on_post:个性化修改Banner案例二：Image转ASCII文字版本Bannner</h3></blockquote><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Banner/SpringBoot-Banner-luojay.png" alt></p><blockquote><h3 id="triangular-flag-on-post-个性化修改Banner案例三：脑洞新奇的佛祖Bannner"><a href="#triangular-flag-on-post-个性化修改Banner案例三：脑洞新奇的佛祖Bannner" class="headerlink" title=":triangular_flag_on_post:个性化修改Banner案例三：脑洞新奇的佛祖Bannner"></a>:triangular_flag_on_post:个性化修改Banner案例三：脑洞新奇的佛祖Bannner</h3></blockquote><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Banner/SpringBoot-Banner-fozu.png" alt></p><blockquote><h4 id="bookmark-tabs-个性化修改Banner修改步骤"><a href="#bookmark-tabs-个性化修改Banner修改步骤" class="headerlink" title=":bookmark_tabs: 个性化修改Banner修改步骤"></a>:bookmark_tabs: 个性化修改Banner修改步骤</h4></blockquote><ol><li><p>在src/main/resources路径下新建一个banner.txt文件</p></li><li><p>在下面三个自定义的Banner的网站转换好Banner相关的ASCII字符</p></li><li><p>在banner.txt中填入转换好Banner相关的ASCII字符即可</p></li></ol><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Banner/SpringBoot-Banner-Path.png" alt="SpringBoot-Banner-Path"></p><blockquote><h4 id="link-自定义Banner网站链接"><a href="#link-自定义Banner网站链接" class="headerlink" title=":link: 自定义Banner网站链接"></a>:link: 自定义Banner网站链接</h4></blockquote><p><a href="http://patorjk.com/software/taag" rel="external nofollow noopener noreferrer" target="_blank">文本转ASCII神奇网站</a></p><p><a href="http://www.network-science.de/ascii/" rel="external nofollow noopener noreferrer" target="_blank">ascii生成器</a></p><p><a href="http://www.degraeve.com/img2txt.php" rel="external nofollow noopener noreferrer" target="_blank">图片转TXT</a></p><blockquote><h4 id="link-有关Banner的修改比较好的博文推荐-引用"><a href="#link-有关Banner的修改比较好的博文推荐-引用" class="headerlink" title=":link:有关Banner的修改比较好的博文推荐(引用)"></a>:link:有关Banner的修改比较好的博文推荐(引用)</h4></blockquote><p><a href="http://blog.didispace.com/spring-boot-banner/" rel="external nofollow noopener noreferrer" target="_blank">【程序猿DD 】新年彩蛋：Spring Boot自定义Banner</a></p><p><a href="https://blog.csdn.net/A924110137/article/details/91797859" rel="external nofollow noopener noreferrer" target="_blank">Srpingboot启动彩蛋banner修改（让springboot多点乐趣）</a></p><blockquote><h3 id="Spring使用YAML修改Tomcat端口"><a href="#Spring使用YAML修改Tomcat端口" class="headerlink" title="Spring使用YAML修改Tomcat端口"></a>Spring使用YAML修改Tomcat端口</h3></blockquote><p>​        SpringBoot使用一个全局的配置文件，配置文件名是application(固定),但application.properties和application.yml两种格式，学过JavaSE的基本都会porperties文件配置，这里来讲讲<strong>YAML</strong>文件</p><blockquote><h3 id="YAML与XML类比"><a href="#YAML与XML类比" class="headerlink" title="YAML与XML类比"></a>YAML与XML类比</h3></blockquote><p>​        <strong>YAML</strong>是一种和xml类似但比xml简洁的标记语言文件，<strong>yml</strong>是<strong>YAML</strong>文件的后缀名。</p><p>下面分别以xml和yml写一段同样功能的标记语言来表示Tomcat服务器端口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//xml文件记录服务端口为8080</span><br><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//yaml文件记录服务端口为8080</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:8080</span></span><br></pre></td></tr></table></figure><p>​        通过上面的代码比较，就可以看出，yml用两个标签和两个冒号就能完整表示一个服务端口，而xml文件则需要四个标签才能达到同样的功能，所以在简洁程度完爆xml文件，后来被SpringBoot推荐用作来记录配置信息的文件</p><blockquote><h3 id="YAML与Properties类比"><a href="#YAML与Properties类比" class="headerlink" title="YAML与Properties类比"></a>YAML与Properties类比</h3></blockquote><p>​        分别先上一段properties和yml表示数据库连接的配置信息，对比你会发现yaml比porperties更加简洁。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">###properties config mysql info</span><br><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/user?characterEncoding=utf8</span><br><span class="line">jdbc.username=luojay</span><br><span class="line">jdbc.password=luojay</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###yaml config mysql info</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">driver:com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:mysql://localhost:3306/user?characterEncoding=utf8</span></span><br><span class="line"><span class="attr">username:luojay</span></span><br><span class="line"><span class="attr">password:luojay</span></span><br></pre></td></tr></table></figure><blockquote><h3 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h3></blockquote><p>​        之所以跟porperties类比，是因为yaml和porperties语法有类似，都是用键值对(key-value)来表示一个配置信息项</p><p>不同的点在于：</p><p>1.键值对匹配的符号不同</p><p>porperties用<strong>等于号</strong>匹配键和值         例如<code>username=luojay</code></p><p>yaml用<strong>冒号</strong>匹配键和值                     例如<code>username:luojay</code></p><p>2.yaml严格匹配缩进来表示层级关系</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###username和password在jdbc层级下是同一层级关系</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">username:luojay</span></span><br><span class="line"><span class="attr">password:luojay</span></span><br><span class="line"><span class="comment">###username和password在jdbc层级下不是同一层级关系</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">username:luojay</span></span><br><span class="line"><span class="attr">password:luojay</span></span><br></pre></td></tr></table></figure><p>3.yaml严格区分大小写，大小写不同的属性和值是不同的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">USERNAME:</span><span class="string">LUOJAY</span> </span><br><span class="line"><span class="attr">username:</span><span class="string">luojay</span></span><br><span class="line"><span class="comment">###区分大小写luojay是不同的属性值</span></span><br></pre></td></tr></table></figure><p>​        这里以application.yml为例修改端口值，SpringBoot默认的Tomcat是内嵌在Jar包中且端口是8080 修改配置文件的作用：SpringBoot在底层都给我们自动配置好，通过修改端口可以解决开发中常见的端口被占用的冲突问题，可以同时部署多个应用在多个Tomcat上</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Banner/SpringBoot-Banner-Port.png" alt></p><p>启动项目查看控台日志，查看端口是否已经改好</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/SpringBoot-Banner/SpringBoot-Banner-log.png" alt></p><blockquote><h3 id="文章配套的源码已传到Github-sparkles"><a href="#文章配套的源码已传到Github-sparkles" class="headerlink" title="文章配套的源码已传到Github:sparkles:"></a>文章配套的源码已传到Github:sparkles:</h3></blockquote><p><a href="https://github.com/bobi8344/SpringBoot-Study/tree/master/springboot-banner" rel="external nofollow noopener noreferrer" target="_blank">SpringBoot-Banner</a></p><p>欢迎clone 如果有帮助，请给个start！</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot2.X系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap两种遍历方式</title>
      <link href="/HashMap%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F.html"/>
      <url>/HashMap%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<p>写在最前面的话：HashMap是Java集合中面试会被问得最多的一个知识点，而HashMap的遍历方法可以很好融合Java的泛型，自定义封装类的知识，所以很又必要掌握它的遍历。<a id="more"></a></p><h3 id="HashMap的遍历方式"><a href="#HashMap的遍历方式" class="headerlink" title="HashMap的遍历方式"></a>HashMap的遍历方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Java 官方API文档提供三种视图给我们来遍历元素：</span><br><span class="line">1. Set&lt;K&gt; keySet() ：返回一个 Set的key视图包含在这个Map。</span><br><span class="line">2. Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() ：返回一个 Set视图的映射包含在这个Map。</span><br><span class="line">3. Collection&lt;V&gt; values() ：返回一个 Collection视图的值包含在这个Map。  </span><br><span class="line">这里只记录前面两种方式遍历Map，所谓遍历就是要找到key和value值，并取出这两个值。</span><br></pre></td></tr></table></figure><p>HashMap数据结构图示，默认创建长度为16的数组，根据哈希值计算在数组的索引位置，然后在相同索引位置的添加节点元素并以单向链表的形式排列节点元素。<br><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/JavaSE-HashMap/JavaSE-HashMap-store.png" alt><br>其中每个节点元素的结构由Entry&lt;key,value&gt;和Node&lt;k,v&gt;组成，这里只对Entry&lt;key,value&gt;作图解释<br><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/JavaSE-HashMap/JavaSE-HashMap-Entry.png" alt></p><p>方式一：通过Set的key视图来遍历即通过 API文档中Set<k> keySet() 来获取，这种方式获取的思路如下：</k></p><p>1.通过HashMap中的keySet() 获取到所有的HashMap中的key,存放在一个Set集合中</p><p>2.遍历Set集合中的key去找每一个Key所对应的的value值</p><p>通过Set视图遍历就是一开始只会获取到一组Key的值，只知道Set集合里面的Key如下图所示</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/JavaSE-HashMap/JavaSE-HashMap-KeyValue.png" alt></p><p>遍历Set集合中的key去找每一个Key所对应的的value值：按图中①到④的方式依次遍历</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/JavaSE-HashMap/JavaSE-HashMap-keyeach.png" alt></p><p>如果理解上述的思路及过程，那么便可以解决HashMap嵌套HashMap的问题</p><p>这里举个栗子：高中时候大多数学校都会划分重点班（实验班）和普通班，来因材施教（为了升学率）。</p><p>所以以这个场景为例提出下列需求，加深对方式一的理解：</p><table><thead><tr><th>学号</th><th>姓名</th><th>年龄</th><th>班级类型</th></tr></thead><tbody><tr><td>20190201</td><td>bobi</td><td>21</td><td>普通班（NormalClass）</td></tr><tr><td>20190202</td><td>luojie</td><td>22</td><td>普通班（NormalClass）</td></tr><tr><td>20190101</td><td>jay</td><td>18</td><td>重点班（AdvancedClass）</td></tr><tr><td>20190102</td><td>rose</td><td>16</td><td>重点班（AdvancedClass）</td></tr></tbody></table><p>将普通班所有学生各自封装成一个HashMap对象，重点班的所有学生封装成一个HashMap,学生封装成学生类（字段：姓名和年龄），然后再把两个HashMap对象存放在HashMap中，遍历输出如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Advancedclass</span><br><span class="line"><span class="number">20190102</span>------Student [name=rose, age=<span class="number">16</span>]</span><br><span class="line"><span class="number">20190101</span>------Student [name=jay, age=<span class="number">18</span>]</span><br><span class="line">Normalclass</span><br><span class="line">                <span class="number">20190201</span>------Student [name=bobi, age=<span class="number">21</span>]</span><br><span class="line">                <span class="number">20190202</span>------Student [name=luojie, age=<span class="number">22</span>]</span><br></pre></td></tr></table></figure><p>这里只给出Student类的字段，利用系统生成重写toString(),equals(),HashCode()和生成Getter及Setter即可完成JavaBean的标准书写，用于封装学生类数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">private String name; //姓名</span><br><span class="line">private Integer age; //年龄</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写添加学生数据的方法，返回双重HashMap对象seniorSchool抽象表示高中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> HashMap&lt;String,HashMap&lt;String,Student&gt;&gt; addStudent() &#123;</span><br><span class="line">HashMap&lt;String,HashMap&lt;String,Student&gt;&gt; seniorSchool = </span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;String,HashMap&lt;String,Student&gt;&gt;();<span class="comment">//编写双重HashMap表示高中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个HashMap对象advancedClass表示重点班，往里加数据</span></span><br><span class="line">HashMap&lt;String, Student&gt; advancedClass = <span class="keyword">new</span> HashMap&lt;String,Student&gt;();</span><br><span class="line">advancedClass.put(<span class="string">"20190101"</span>, <span class="keyword">new</span> Student(<span class="string">"jay"</span>,<span class="number">18</span>));  </span><br><span class="line">advancedClass.put(<span class="string">"20190102"</span>, <span class="keyword">new</span> Student(<span class="string">"rose"</span>,<span class="number">16</span>)); </span><br><span class="line">seniorSchool.put(<span class="string">"Advancedclass"</span>, advancedClass);</span><br><span class="line"><span class="comment">//创建一个HashMap对象normalClass表示普通班，往里加数据</span></span><br><span class="line">HashMap&lt;String, Student&gt; normalClass = <span class="keyword">new</span> HashMap&lt;String,Student&gt;();</span><br><span class="line">normalClass.put(<span class="string">"20190201"</span>, <span class="keyword">new</span> Student(<span class="string">"bobi"</span>,<span class="number">21</span>));  </span><br><span class="line">normalClass.put(<span class="string">"20190202"</span>, <span class="keyword">new</span> Student(<span class="string">"luojie"</span>,<span class="number">22</span>)); </span><br><span class="line">seniorSchool.put(<span class="string">"Normalclass"</span>,normalClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> seniorSchool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写遍历高中每一个班级的每一个学生并打印输出的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HashMap&lt;String, HashMap&lt;String, Student&gt;&gt; senior = addStudent();</span><br><span class="line"><span class="comment">//遍历外层的HashMap,调用外层HashMap对象.keySet()返回所有班级名称的Key存放在Set集合中</span></span><br><span class="line">    <span class="comment">//Set&lt;String&gt; classNames = senior.keySet();</span></span><br><span class="line"><span class="keyword">for</span> (String className : senior.keySet()) &#123;</span><br><span class="line">System.out.println(className+<span class="string">"\t"</span>);</span><br><span class="line">            <span class="comment">//通过每一个key值，调用外层HashMap对象.get(key)去获取所有value（即班级类型）</span></span><br><span class="line">HashMap&lt;String, Student&gt; classMaps = senior.get(className);</span><br><span class="line"><span class="comment">//Set&lt;String&gt; studentIds = classMaps.keySet();</span></span><br><span class="line"><span class="keyword">for</span>(String studentId:classMaps.keySet()) &#123;</span><br><span class="line">                <span class="comment">//内层也是调用KeySet()方法返回Set视图,然后通过每一个Key找到对应Value值</span></span><br><span class="line">System.out.println(<span class="string">"\t\t"</span>+studentId+<span class="string">"------"</span>+classMaps.get(studentId));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试方法来测试打印输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">getStudent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Advancedclass</span><br><span class="line">20190102------Student [name=rose, age=16]</span><br><span class="line">20190101------Student [name=jay, age=18]</span><br><span class="line">Normalclass</span><br><span class="line">                20190201------Student [name=bobi, age=21]</span><br><span class="line">                20190202------Student [name=luojie, age=22]</span><br></pre></td></tr></table></figure><p>方式二：通过 Set视图的映射包含在这个Map来遍历即调用 API文档中Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() ，这里 Set视图的映射指的是Entry类，它是一个Map内部类，保存了键值对的地址，所以称为映射。</p><p>涉及到的方法在Java官方文档Map.Entry&lt;K,V&gt;接口中可以找到下面的两个方法</p><table><thead><tr><th><code>K</code></th><th><code>getKey()</code>  返回对应于此项的键。</th></tr></thead><tbody><tr><td><code>V</code></td><td><code>getValue()</code>  返回对应于此项的值。</td></tr></tbody></table><p>这种方式获取的思路如下：</p><p>1.通过调用HashMap对象的entrySet()方法返回所有键值对的地址值，存放在一个Set集合中</p><p>2.通过地址值获取对应的key和value（调用上面的<code>getKey()</code>和<code>getValue()</code>）</p><p>实现的图解实例：</p><p>一开始只能获取到Set的Entry类中的地址值，其他的均获取不到</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/JavaSE-HashMap/JavaSE-HashMap-EntryEach.png" alt></p><p>接下来通过每一个地址值0xxxx去找到对应的键值对对象，通过它调用<code>getKey()</code>，<code>getValue()</code></p><p>获取key和value。调用<code>getKey()</code>,<code>getValue()</code>逐个获取key和value，一直获取到最后</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/JavaSE-HashMap/JavaSE-HashMap-getKeyValue.png" alt></p><p>这里还是以上面的高中划分重点班和普通班的场景为例子，使用方式二遍历输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStudentForEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HashMap&lt;String, HashMap&lt;String, Student&gt;&gt; senior = addStudent();</span><br><span class="line"><span class="comment">//调用外层HashMap的entrySet()获取到外层所有班级的entries</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, HashMap&lt;String, Student&gt;&gt;&gt; classentries=senior.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, HashMap&lt;String, Student&gt;&gt; classentry:classentries) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(classentry.getKey());</span><br><span class="line"><span class="comment">//循环遍历每个classentry获取到每个学生类的HashMap集合</span></span><br><span class="line">HashMap&lt;String, Student&gt; studentMap = classentry.getValue();</span><br><span class="line"><span class="comment">//学生类HashMap对象调用entrySet(),获取到所有学生类的实体studentEntries</span></span><br><span class="line">Set&lt;Map.Entry&lt;String, Student&gt;&gt; studentEntries= studentMap.entrySet();</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, Student&gt; studentEntry:studentEntries) &#123;</span><br><span class="line"><span class="comment">//循环遍历每个学生类实体studentEntry，通过它来调用getKey()和getValue()获取键和值</span></span><br><span class="line">System.out.println(<span class="string">"\t\t"</span>+studentEntry.getKey()+<span class="string">"---"</span>+studentEntry.getValue()); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/JavaSE-HashMap/JavaSE-HashMap-Outputresult.png" alt></p><h3 id="遍历总结"><a href="#遍历总结" class="headerlink" title="遍历总结"></a>遍历总结</h3><p>HashMap的嵌套遍历需要我们学会分步拆解，从整体出发，屏蔽干扰，例如</p><p><code>HashMap&lt;String,HashMap&lt;String,Student&gt;&gt; senior</code></p><p>可以先把内层的<code>HashMap&lt;String,Student&gt;</code>看作是一个value,从而思想上简化成一个HashMap变成如下代码</p><p>外层HashMap经过简化后变成<code>HashMap&lt;String,value&gt; senior</code>，变成熟悉HashMap&lt;key,value&gt;形式，只不过key的类型是String,value是HashMap&lt;String,Student&gt;，这里我们简化后手写代码就会屏蔽HashMap泛型的干扰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.Set&lt;String&gt; seniorKeys = senior.keySet();</span><br><span class="line"><span class="comment">//seniorKeys表示所有key值组成String类型的Set集合的对象 senior表示HashMap对象地址的引用</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.<span class="keyword">for</span>(String seniorKey:seniorKeys)&#123;</span><br><span class="line">    System.out.println(seniorKey);<span class="comment">//此处依次输出的是Advancedclass和Normalclass</span></span><br><span class="line">HashMap&lt;String,Student&gt; classvalue = senior.get(seniorKey);</span><br><span class="line"><span class="comment">//这里返回的每一个值都是外层value的值,用HashMap&lt;String,Student&gt;替换</span></span><br><span class="line"><span class="comment">//seniorKeys去掉后，理解为每一个key，通过调用HashMap对象.get(key)获取键值对映射中key所对应value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化后外层HashMap后，得到内层HashMap相对而言就简单很多，变成以下代码块</p><p><code>HashMap&lt;String,Student&gt; classvalue = senior.get(seniorKey)</code>,这里的Key类型是String,value的类型是Studen类型，内层HashMap的对象是classvalue,按照<code>HashMap&lt;key,value&gt;</code>遍历即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; studentkeys = classvalue.keySet();</span><br><span class="line">for(String studentkey:studentkeys)&#123;</span><br><span class="line">System.out.println(studentkey);//这里输出的是学号，学号是存放在内层HashMap的Key里</span><br><span class="line">Student student = classvalue.get(studentkey);</span><br><span class="line">System.out.println(student);//这里输出的是具体学生姓名和年龄信息，因为重写ToString()</span><br><span class="line">//所以表现为Student [name=xxxx, age=16]形式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的是简化思想的代码，熟练后可以把<code>Set&lt;String&gt; studentkeys = classvalue.keySet()</code>以及<code>Student student = classvalue.get(studentkey)</code>代码优化，使代码更加简洁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String seniorKey:senior.keySet())&#123;</span><br><span class="line">    System.out.println(seniorKey);</span><br><span class="line">HashMap&lt;String,Student&gt; classvalue = senior.get(seniorKey);</span><br><span class="line">    <span class="keyword">for</span>(String studentkey:classvalue.keySet())&#123;</span><br><span class="line">        System.out.println(<span class="string">"\t\t"</span>+studentkey+<span class="string">"---"</span>+classvalue.get(studentkey));</span><br><span class="line">        <span class="comment">// \t表示制表符，使输出更好看一点而已</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二的总结这里就不总结了，有些东西总是需要自己提炼才会记忆深刻，拿来主义看的懂固然很好，但相信来得快忘记得也挺快，还需自己一步一步地学习，才能有所提高。</p><h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>最后的最后，写这篇博文时候，其实是为了提高自己的编程思想，两层的HashMap嵌套其实是个中间点，经过思想上的简化，可以简化成单层HashMap，由此对于三层及以上的HashMap嵌套，采用简化思想也会迎刃而解，只不过是时间和熟练的问题，而对于其他List嵌套HashMap的<code>List&lt;HashMap&lt;String,Integer&gt;&gt;</code>那么就更加容易解决，因为HashMap嵌套是双列集合嵌套双列集合，对于一个单列嵌套双列，是不是简化了一个维度？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap学习</title>
      <link href="/HashMap%E5%AD%A6%E4%B9%A0.html"/>
      <url>/HashMap%E5%AD%A6%E4%B9%A0.html</url>
      
        <content type="html"><![CDATA[<p>HashMap是Java集合下Map接口的重要实现类，在常规的Java基础面试题中是个高频的考点，由HashMap可以考查到求职者的基础功底和学习能力，学习深度,甚至于可以通过HashMap深入到考查数据结构。<a id="more"></a></p><h2 id="本文思维导图"><a href="#本文思维导图" class="headerlink" title="本文思维导图"></a>本文思维导图</h2><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/Java/HashMap.png?q-sign-algorithm=sha1&q-ak=AKIDVnsTrvTgFf9G9myYbpmT3OVgeOypNtAE&q-sign-time=1567431563;1630503563&q-key-time=1567431563;1630503563&q-header-list=&q-url-param-list=&q-signature=ea88575ab261704c0152ca4977ee7e721d2d309c" alt="HashMap知识点"></p><h2 id="HashMap的存储特点"><a href="#HashMap的存储特点" class="headerlink" title="HashMap的存储特点"></a>HashMap的存储特点</h2><p>HashMap是Map接口的实现类，所以Map有的特点它也有：<br>1.HashMap存储的是以键值对形式双列数据，键值对即（key-value）<br>2.HashMap存储的是无序不可重复的数据<br>3.HashMap存储的数据可以是null值，key和value都可以是null值<br>4.HashMap的不可重复特指Key不可重复,value可以是重复的。</p><h2 id="HashMap如何保证添加的数据不重复"><a href="#HashMap如何保证添加的数据不重复" class="headerlink" title="HashMap如何保证添加的数据不重复"></a>HashMap如何保证添加的数据不重复</h2><p>HashMap底层数据结构是哈希表，在jdk1.7版本表现形式是数组+链表，jdk1.8中是数组+链表+红黑树，当需要往哈希表中添加数据时需要通过hash值和Equals方法去判断数据在哈希表中是否存在相同的数据。</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/Java/hash_data_structure.png?q-sign-algorithm=sha1&q-ak=AKIDVnsTrvTgFf9G9myYbpmT3OVgeOypNtAE&q-sign-time=1567438101;1630510101&q-key-time=1567438101;1630510101&q-header-list=&q-url-param-list=&q-signature=1437633863269cb1def3067fe2431071391b9a6f" alt="hashMap数据结构"></p><p>实现过程：<br>1.首先第一次往哈希表添加数据时，会计算数据的key的hash值，从而计算出存放在数组索引位置，因为第一次添加，哈希表里面为空不涉及到比较hash值和equals方法，所以直接添加。<br>2.第二次添加数据时，也会计算数据的key的hash值，从而计算出存放在数组索引位置，当第二次添加时，算出的索引位置后会在数组中的索引位置查看是否有元素，没有也则直接添加。<br>3.当多次添加后，默认为16长度的大小数组大部分索引位置都有元素时，再次添加数据进来，计算出索引位置相同时，这时就要判断数据是否重复。</p><pre><code>当索引位置相同时，这又称为哈希碰撞。通过比较键值对中key值的hash值是否和数组中已有的键值对的key的hash值相同。    如果不相同的hash值，则在相同的索引位置以链表的形式把数据添加进去    如果相同hash值，则比较通过equals方法比较两个key值是否相同        如果不相同，则也在相同的索引位置以链表的形式把数据添加进去        如果相同，则不添加数据。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">e = p;</span><br><span class="line"><span class="comment">//这里的代码对应上述的第三点</span></span><br></pre></td></tr></table></figure><p>总结：</p><table><thead><tr><th></th><th>比较索引值</th><th>比较hash值</th><th>比较equals方法</th><th>情况描述</th></tr></thead><tbody><tr><td>首次调用put()</td><td>不需要</td><td>不需要</td><td>不需要</td><td>直接添加</td></tr><tr><td>发生哈希碰撞</td><td>需要</td><td>需要</td><td>需要</td><td>hash值同equals值为false,替换value值</td></tr><tr><td>发生哈希碰撞</td><td>需要</td><td>需要</td><td>需要</td><td>hash值不同equals值为false,链表式添加</td></tr><tr><td>发生哈希碰撞</td><td>需要</td><td>需要</td><td>需要</td><td>hash值不同equals值为true,不添加</td></tr></tbody></table><h2 id="hash值如何计算"><a href="#hash值如何计算" class="headerlink" title="hash值如何计算"></a>hash值如何计算</h2><p>由上面的的保证HashMap数据不重复就可以看出hash值的重要性，那么hash值到低是什么东西？<br>Java中有一种哈希表数据结构,它通过hash算法算出的结果就是hash值,这个算法叫hash算法.<br>hash值怎么算?先了解hashCode方法,它是Object类中的一个用于计算哈希码的值即hash值的方法<br>这里我自定义一个JavaBean的Student类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">     result = <span class="number">31</span> * result + (age != <span class="keyword">null</span> ? age.hashCode() : <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过分析生成hashCode()，可以得知，hashCode涉及的计算算法与成员变量（name,age）有关<br>如果成员变量是基本数据类型的值， 那么用这个值 直接参与计算；<br>如果成员变量是引用数据类型的值，那么获取到这个成员变量的哈希码值后，再参数计算；</p><p>再通过查看String类重写的hashCode()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h = hash;</span><br><span class="line">      <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">char</span> val[] = value;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">              h = <span class="number">31</span> * h + val[i];</span><br><span class="line">          &#125;</span><br><span class="line">          hash = h;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>再写一个再main方法中的小测试：输出结果值为：3029737</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String book = <span class="keyword">new</span> String(<span class="string">"book"</span>);</span><br><span class="line">System.out.println(book.hashCode());</span><br></pre></td></tr></table></figure><p>下面就来讲解这个值是怎么求出来的<br>book这四个字符在ASCII码表中的值分别是98，111，111，107</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> val[] = value;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">               h = <span class="number">31</span> * h + val[i];</span><br><span class="line">           &#125;</span><br><span class="line">           hash = h;</span><br></pre></td></tr></table></figure><p>根据上面String重写的hashCode的核心代码：<br>31<em>98+98+31</em>111+111+31<em>111+111+31</em>107+107=3029737</p><p>所以对象的哈希码就是通过这样算出来的</p><p>那么这里有个关键问题：为什么要乘以31？</p><ol><li>因为31是一个奇质数，奇质数又是什么鬼？其实就是奇数中的质数，质数是与它相乘的数的结果只能被1和本身还有相乘数整除。<br>这样选择31作为乘积数的原因是希望能减少哈希码冲突，31是质子数中一个“不大不小”的存在，如果你使用的是一个如2的较小质数，那么得出的乘积会在一个很小的范围，很容易造成哈希值的冲突</li><li>31可以被JVM优化</li></ol><p>JVM里最有效的计算方式就是进行位运算了<br>左移运算 &lt;&lt; : 左边的最高位丢弃，右边补全0（把 &lt;&lt; 左边的数据*2的移动次幂）。</p><p>右移运算 &gt;&gt; : 把&gt;&gt;左边的数据/2的移动次幂。</p><p>无符号右移运算&gt;&gt;&gt; : 无论最高位是0还是1，左边补齐0。 　　</p><p>31 * i = (i &lt;&lt; 5) - i（左边  31<em>2=62,右边   2</em>2^5-2=62） 左右两边相等，JVM就可以高效的进行计算</p><p>31=  2的五次方-1   =（1&lt;&lt;5）-1  </p><p>(1&lt;&lt;5)-1 =    二进制的000001向左移动5位    100000-1=32-1=31</p><h2 id="hash值在HashMap中的应用"><a href="#hash值在HashMap中的应用" class="headerlink" title="hash值在HashMap中的应用"></a>hash值在HashMap中的应用</h2><p>hash值主要用于计算键值对存放的索引位置,利用hashCode()同时再结合对应JDK版本的扰动算法就能算出索引位置。这里主要用到三个运算符：与运算&amp; ,异或运算符^,无符号右移位运算符&gt;&gt;&gt;</p><p>与运算&amp;:     0&amp;0 =0 ,0&amp;1=0,1&amp;1=1,1&amp;0=0</p><p>异或运算^:     0&amp;0 =0 ,0&amp;1=1,1&amp;1=0,1&amp;0=1</p><p>无符号右移位运算符&gt;&gt;&gt;:    把二进制数向右移动多少位 如（1000 0000&gt;&gt;&gt;7）=0000 0001</p><h3 id="JDK1-8中的哈希表索引值计算"><a href="#JDK1-8中的哈希表索引值计算" class="headerlink" title="JDK1.8中的哈希表索引值计算"></a>JDK1.8中的哈希表索引值计算</h3><p>将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">       <span class="comment">//哈希码右位移运算16位再异或运算哈希码</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">         <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); </span><br><span class="line">         <span class="comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1）默认为16 数组长度-1=15=00001111，最终得到存储在数组table的位置（即数组下标、索引）</span></span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>还是以上面的3029737为例 转换为二进制对应为0010 1110 0011 1010 1110 1001</p><p><img src="https://bobi-1258060032.cos.ap-chengdu.myqcloud.com/Java/hashcode_math.png?q-sign-algorithm=sha1&q-ak=AKIDVnsTrvTgFf9G9myYbpmT3OVgeOypNtAE&q-sign-time=1567440718;1630512718&q-key-time=1567440718;1630512718&q-header-list=&q-url-param-list=&q-signature=b13ec9d27e562c8eb8d5f94918e45d96cedd28c0" alt="hash值计算"></p><p>所以最终算出哈希表索引 index=0111 转换为10进制为7</p><h3 id="JDK1-7中的哈希表索引值计算"><a href="#JDK1-7中的哈希表索引值计算" class="headerlink" title="JDK1.7中的哈希表索引值计算"></a>JDK1.7中的哈希表索引值计算</h3><p>将键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        h ^= k.hashCode(); </span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">     &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">          <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>); </span><br><span class="line">          <span class="comment">// 将对哈希码扰动处理后的结果 与运算(&amp;) （数组长度-1）默认为16 数组长度-1=15=00001111，最终得到存储在数组table的位置（即数组下标、索引）</span></span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>只是运算次数改变，本质上的套路都是一样，所以懂得计算原理无论多少次运算都能轻松掌握。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在半天内利用Hexo+Github Page搭建个人博客</title>
      <link href="/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8A%E5%A4%A9%E5%86%85%E5%88%A9%E7%94%A8Hexo+Github%20Page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html"/>
      <url>/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%8D%8A%E5%A4%A9%E5%86%85%E5%88%A9%E7%94%A8Hexo+Github%20Page%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
      
        <content type="html"><![CDATA[<p>作为一个程序员，个人觉得博客和Github用来记录自己的学习历程最为合适不过，相信大部分的学习编程的人应该都会用过Github,而Github Page 依托着Github的项目适合用来展示项目的Demo。这里我们用来Hexo+Github Page搭建个人博客最适合不过了。<a id="more"></a></p><h3 id="需要具备的知识"><a href="#需要具备的知识" class="headerlink" title="需要具备的知识"></a>需要具备的知识</h3><pre><code>1.Git的基本命令知识2.Windows的基本命令（DOS命令）3.爱折腾的意识（其实就很简单但需要踩坑爬坑）4.一定的搜索学习能力</code></pre><h3 id="需要用到的工具"><a href="#需要用到的工具" class="headerlink" title="需要用到的工具"></a>需要用到的工具</h3><pre><code>1.Node.js(6.9版本以上)2.Git&amp;Github3.Hexo</code></pre><h3 id="（一）安装Node-js"><a href="#（一）安装Node-js" class="headerlink" title="（一）安装Node.js"></a>（一）安装Node.js</h3><p>在Windows操作系统下，按下win+R 后输入 cmd 调出 windows命令行终端查看Node.js版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>如果显示版本不是6.9或以上，请重新安装。如果显示不是内部处理文件，则未安装Node.js<br><a href="https://nodejs.org/en/" rel="external nofollow noopener noreferrer" target="_blank">Node官网</a>    下载安装node.js</p><p>安装完Node.js后需要配置一下windows环境变量，在我的电脑–&gt;高级系统设置–&gt;高级–&gt;环境变量 </p><p> 配置Path环境变量以便DOS命令能够运行Node.js命令</p><p>Path环境变量中加入你安装Node目录的node.exe所在的目录，这里我安装在G盘下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;G:\Instrallations\nodejs</span><br></pre></td></tr></table></figure><p>再次检查Node.js版本，在Dos中输入下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>显示的版本号在6.9版本或以上即为完成Node.js安装</p><h3 id="（二）安装Git"><a href="#（二）安装Git" class="headerlink" title="（二）安装Git"></a>（二）安装Git</h3><p><a href="https://git-scm.com/" rel="external nofollow noopener noreferrer" target="_blank">Git官网</a>        下载安装Git<br>可以自行下载安装，如果安装步骤不会可以百度或者可以参考博文    <a href="https://www.cnblogs.com/ximiaomiao/p/7140456.html" rel="external nofollow noopener noreferrer" target="_blank">Git安装和使用</a></p><p>安装好Git之后，需要在    我的电脑–&gt;高级系统设置–&gt;高级–&gt;环境变量  配置Path环境变量<br>这里以我安装的Git目录为例，请自行替换路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;G:\Instrallations\Git</span><br></pre></td></tr></table></figure><p>然后在windows dos命令行中输入以下命令 是否显示git的版本信息 是则表示安装成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h3 id="（三）创建Github和Github-Page"><a href="#（三）创建Github和Github-Page" class="headerlink" title="（三）创建Github和Github Page"></a>（三）创建Github和Github Page</h3><p>去<a href="https://github.com/" rel="external nofollow noopener noreferrer" target="_blank">Github官网</a> 注册一个Github账号，需要注意邮箱必须填常用的，它是Github用来发提示信息和推送信息给你的，在忘记密码后也是通过邮箱找回</p><p>接着去<a href="https://pages.github.com/" rel="external nofollow noopener noreferrer" target="_blank">Github Page官网</a>    按照官网的详细教程 创建个人项目为主页的静态页面。（此处英文水平不是很好的建议使用网页的翻译为中文）</p><h3 id="（四）Git与Github设置SSH-通过Git把Github刚刚创建的项目克隆到本地库"><a href="#（四）Git与Github设置SSH-通过Git把Github刚刚创建的项目克隆到本地库" class="headerlink" title="（四）Git与Github设置SSH,通过Git把Github刚刚创建的项目克隆到本地库"></a>（四）Git与Github设置SSH,通过Git把Github刚刚创建的项目克隆到本地库</h3><p>在Git Bash中输入以下命令，如果显示：No such file or directory 则表示本地没有SSH秘钥，需要我们新建一个SSH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure><p>生成本地的SSH,这里邮箱地址可以输入自己的邮箱地址，这里的「-C」的是大写的「C」</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"邮件地址@qq.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key(/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</span><br></pre></td></tr></table></figure><p>然后设置一个密码（后面使用Git提交到Github的时候会用到，这里设置好请记录下来）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):&lt;输入加密串&gt;</span><br><span class="line">Enter same passphrase again:&lt;再次输入加密串&gt;</span><br></pre></td></tr></table></figure><p>注意：因为Linux 命令(Git Bash)下输入密码是无提示(即不会显示<strong>***</strong>)，这里直接输入即可，输入完按回车。</p><p>检查是否生成SSH秘钥的方法：打开C:\Users\Administrator\目录看是否存在id_rsa以及id _rsa.pub文件，存在则生成成功</p><h3 id="（五）Git通过SSH连接到Gthub"><a href="#（五）Git通过SSH连接到Gthub" class="headerlink" title="（五）Git通过SSH连接到Gthub"></a>（五）Git通过SSH连接到Gthub</h3><p>登录Github官网点击右上角的 Account Settings—&gt;SSH Public keys —&gt; add another public keys<br>打开上面目录的 id_rsa.pub 文件,全选里面的秘钥内容，复制到Github的Key文本框 点击 add key<br>key上面的标题随便起一个名字即可。</p><p>测试是否连接成功，输入下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@Github.com</span><br></pre></td></tr></table></figure><p>接着会提示你输入之前设定的id_rsa的密码，设定密码是为了保障Github与Git的传输安全</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">'/c/Users/Administrator/.ssh/id_rsa'</span>:</span><br></pre></td></tr></table></figure><p>如果查看结果输出以下信息，则表示成功连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi bobi8344! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access</span></span><br></pre></td></tr></table></figure><h3 id="（六）安装Hexo"><a href="#（六）安装Hexo" class="headerlink" title="（六）安装Hexo"></a>（六）安装Hexo</h3><p><a href="https://hexo.io/" rel="external nofollow noopener noreferrer" target="_blank">hexo官网</a>  安装hexo完全是参考官方的文档，包括后面的设置主题等都是参考官方的文档，这里建议最好是看英文文档，因为网页翻译有时候会翻译得不准确。</p><p>在Windows中执行以下命令安装Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>安装完后，会在C:\Users\Administrator\AppData\Roaming\npm (以我的win10为例）目录下生成<br>node_modules文件夹以及hexo.cmd和hexo，非win10在Dos查看具体目录验证是否成功安装hexo</p><p>安装完Hexo后需要对Hexo进行初始化，官方的文档在blog文件中初始化，这里建议新建在自己方便管理的文件夹例如我在H盘新建hexo文件夹，然后通过Git Bash转到这个文件夹再执行初始化命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><p>初始化完成后会在blog目录下生成以下文件夹及文件</p><p>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes</p><p>然后执行以下命令，在浏览器输入<a href="http://localhost:4000/" rel="external nofollow noopener noreferrer" target="_blank">http://localhost:4000/</a>就可以查看本地生成博客模板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g </span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>做到这一步就基本上已经完成百分之八十</p><h3 id="七-克隆Github远程仓库到本地库并安装Hexo部署插件"><a href="#七-克隆Github远程仓库到本地库并安装Hexo部署插件" class="headerlink" title="(七)克隆Github远程仓库到本地库并安装Hexo部署插件"></a>(七)克隆Github远程仓库到本地库并安装Hexo部署插件</h3><p>在blog下运行Git Bash，执行下面的命令,把clone后面的地址替换成要克隆的仓库的地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/bobi8344/bobi8344.github.io.git</span><br></pre></td></tr></table></figure><p>接着安装Hexo部署插件，一个hexo和Git关联的插件，win+r 输入cmd,调出终端窗口执行下面命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>修改根目录下的 _config.yml 配置文件，注意这里必须使用SSH的方式（前面配置过）提交，否则会提交不了，因为在hexo2.0版本后，https的方式好像有Bug,我也踩了这个坑好久才跳出来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:bobi8344/bobi8344.github.io.git</span><br></pre></td></tr></table></figure><p>最后在Git Bash执行Hexo部署命令，部署到Github上，打开<a href="https://bobi8344.github.io/" rel="external nofollow noopener noreferrer" target="_blank">https://bobi8344.github.io/</a>查看刚才部署的博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
